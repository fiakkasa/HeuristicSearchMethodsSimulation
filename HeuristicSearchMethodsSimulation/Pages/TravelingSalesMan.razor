@page "/TravelingSalesMan"
@using Plotly.Blazor
@using Plotly.Blazor.Traces
@using Plotly.Blazor.ConfigLib
@using Plotly.Blazor.LayoutLib
@using Plotly.Blazor.LayoutLib.GeoLib
@using Plotly.Blazor.LayoutLib.GeoLib.ProjectionLib
@using Plotly.Blazor.Traces.ScatterGeoLib
@implements IDisposable
@inject ITravelingSalesManService travelingSalesManService
@inject ILogger<TravelingSalesMan> logger

<h3>Traveling Sales Man</h3>

<Condition Evaluation="_init">
    <NotMatch>
        <h4 class="d-flex align-items-center">
            <strong class="text-muted">Loading...</strong>
            <span class="flex-fill"></span>
            <i class="spinner-border border-2 text-secondary" role="status" aria-hidden="true"></i>
        </h4>
    </NotMatch>
    <Match>
        <Condition Evaluation="_locationsBySelection.Count > 0">
            <NotMatch>
                <h4>No data available at the moment..</h4>
            </NotMatch>
            <Match>
                <RangeSelector Min="_minSliderValue"
                               Max="_maxSliderValue"
                               Step="1"
                               Value="_sliderValue"
                               ValueChanged="UpdateState"
                               Disabled="_locations.Count == 0" />

                <br />

                <h4>Locations</h4>

                <div class="table-responsive">
                    <table class="table table-striped table-borderless m-0">
                        <thead>
                            <tr>
                                <th>@nameof(Location.Label)</th>
                                <th>@nameof(Location.ShortCode)</th>
                                <th>@nameof(Location.Latitude)</th>
                                <th>@nameof(Location.Longitude)</th>
                            </tr>
                        </thead>
                        <tbody>
                            <Iterations T="Location" Items="_locationsBySelection">
                                <tr>
                                    <td>@context.Label</td>
                                    <td>@context.ShortCode</td>
                                    <td>@context.Latitude</td>
                                    <td>@context.Longitude</td>
                                </tr>
                            </Iterations>
                        </tbody>
                    </table>
                </div>

                <Condition Evaluation="_matrix.Count > 1">
                    <Match>
                        <br />

                        <h4>Matrix</h4>

                        <div class="table-responsive">
                            <table class="table table-borderless m-0">
                                <tbody>
                                    <tr>
                                        <th></th>
                                        <Iterations T="string" Items="_matrix[0].Xlabels">
                                            <th>@context</th>
                                        </Iterations>
                                    </tr>
                                    <Iterations T="LocationRow" Items="_matrix">
                                        <tr>
                                            <th>@context.Ylabel</th>
                                            <Iterations T="LocationToLocation" Items="context.Collection" Context="childContext">
                                                <td class="@CellCssClass(context, childContext)">
                                                    @childContext.DistanceInMeters.ToString("0, Km")
                                                </td>
                                            </Iterations>
                                        </tr>
                                    </Iterations>
                                </tbody>
                            </table>
                        </div>
                    </Match>
                </Condition>

                <div>
                    <br />

                    <div class="flex-shrink-0 d-flex justify-content-center overflow-hidden pb-3">
                        <PlotlyChart Config="_mapChartConfig"
                                     Layout="_mapChartLayout"
                                     Data="_mapChartData"
                                     @ref="_mapChartRef"
                                     style="min-height: 0; height: auto; transform: scale(1.25);" />
                    </div>
                </div>

                <div class="@(_matrix.Count <= 2 ? "d-none" : string.Empty)">
                    <br />

                    <div class="flex-shrink-0 d-flex justify-content-center overflow-hidden">
                        <PlotlyChart Config="_pieChartConfig"
                                     Layout="_pieChartLayout"
                                     Data="_pieChartData"
                                     @ref="_pieChartRef" style="min-height: 0; height: auto;" />
                    </div>
                </div>
            </Match>
        </Condition>
    </Match>
</Condition>

@code {
    private CancellationTokenSource _cts = new();
    private bool _init = false;

    private List<LocationGeo> _locations = new();
    private List<LocationGeo> _locationsBySelection = new();
    private List<LocationRow> _matrix = new();

    private int _minSliderValue = 1;
    private int _maxSliderValue = 10;
    private int _sliderValue = 1;

    private PlotlyChart? _mapChartRef;
    private readonly Config _mapChartConfig = new()
    {
        Responsive = false,
        DisplayLogo = false,
        DisplayModeBar = DisplayModeBarEnum.False,
        AutoSizable = false,
        ShowTips = false,
    };
    private readonly Layout _mapChartLayout = new()
    {
        Width = 640,
        Height = 450,
        AutoSize = false,
        ShowLegend = false,
        Margin = new()
        {
            AutoExpand = false,
            B = 0,
            L = 0,
            R = 0,
            T = 0,
            Pad = 0
        },
        DragMode = DragModeEnum.False,
        Geo = new List<Geo> {
            new Geo
            {
                Scope = ScopeEnum.NorthAmerica,
                Projection = new Projection
                {
                    Type = TypeEnum.AzimuthalEqualArea
                },
                ShowLand = true,
                LandColor = "rgb(243,243,243)",
                CountryColor = "rgb(204,204,204)"
            }
        },
    };
    private List<ITrace> _mapChartData = new List<ITrace> { new ScatterGeo { LocationMode = LocationModeEnum.ISO3 } };

    private PlotlyChart? _pieChartRef;
    private readonly Config _pieChartConfig = new()
    {
        Responsive = false,
        DisplayLogo = false,
        DisplayModeBar = DisplayModeBarEnum.False,
        AutoSizable = false,
        ShowTips = false,
    };
    private readonly Layout _pieChartLayout = new()
    {
        Width = 200,
        Height = 200,
        AutoSize = false,
        ShowLegend = false,
        Margin = new()
        {
            AutoExpand = false,
            B = 0,
            L = 0,
            R = 0,
            T = 0,
            Pad = 0
        }
    };
    private readonly List<ITrace> _pieChartData = new List<ITrace> { new Pie() };

    protected override async Task OnInitializedAsync()
    {
        _init = false;

        _locations = await travelingSalesManService.Fetch(_maxSliderValue, _cts.Token);

        await Task.WhenAll(new[]
        {
            UpdateState(_sliderValue, true),
            new Func<Task>(() => { try { return Task.Delay(250, _cts.Token); }catch{ return Task.CompletedTask; } })()
        }).ContinueWith(_ => _init = true);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender || !_init) return;

        try
        {
            if (_mapChartRef is { } m) await m!.React();

            if (_pieChartRef is { } c) await c!.React();
        }
        catch (Exception ex)
        {
            logger.LogError(ex, ex.Message);
        }
    }

    private string CellCssClass(LocationRow row, LocationToLocation cell) => (
        (row, cell) switch
        {
            { row: { Min: { } }, cell: _ } when row.Min.Key == cell.Key => "min-distance text-success",
            { row: { Max: { } }, cell: _ } when row.Max.Key == cell.Key => "max-distance text-danger",
            { row: _, cell: { DistanceInMeters: 0 } } => "text-muted",
            _ => string.Empty
        } + $" ordinal-from-origin-{cell.OrdinalFromOrigin}"
    ).Trim();

    private Task UpdateState(int sliderValue) => UpdateState(sliderValue, false);

    private async Task UpdateState(int sliderValue, bool deferNotifyingStateChanged)
    {
        try
        {
            _sliderValue = sliderValue;
            _locationsBySelection = _locations.Take(_sliderValue).ToList();
            _matrix = await travelingSalesManService.CalculateMatrix(_locationsBySelection, _cts.Token);

            var mapMarkerData =
                await travelingSalesManService.CalculateMapMarkers(_locationsBySelection, _cts.Token) is { Count: > 0 } mc
                    ? mc
                    : new List<ITrace> { new ScatterGeo { LocationMode = LocationModeEnum.ISO3 } };
            var samplePieData =
                await Task.Run(
                    () =>
                    {
                        var pieChartDataDict =
                            _matrix.Aggregate<LocationRow, Dictionary<string, LocationToLocation>>(
                                new Dictionary<string, LocationToLocation>(),
                                (result, row) =>
                                {
                                    if (row.Min is { } min)
                                        result[min.Key] = min;

                                    return result;
                                }
                            );

                        return new Pie
                        {
                            Labels = pieChartDataDict.Values.Select(x => $"{x.DirectionalKey} | {x.ReverseDirectionalKey}").ToList<object>(),
                            Values = pieChartDataDict.Values.Select(x => (object)(long)(x.DistanceInMeters / 1000)).ToList()
                        };
                    },
                    _cts.Token
                );

            _mapChartData.Clear();
            _mapChartData.AddRange(mapMarkerData);

            _pieChartData.Clear();
            _pieChartData.Add(samplePieData);

            if (!deferNotifyingStateChanged) StateHasChanged();
        }
        catch (Exception ex)
        {

            logger.LogError(ex, ex.Message);
        }
    }

    public void Dispose()
    {
        try
        {
            _pieChartRef?.Dispose();
            _mapChartRef?.Dispose();
        }
        catch (Exception ex)
        {
            logger.LogError(ex, ex.Message);
        }

        _cts.Cancel();
    }
}
