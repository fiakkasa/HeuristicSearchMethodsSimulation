@page "/TravelingSalesMan"
@using Plotly.Blazor
@using Plotly.Blazor.Traces
@using Plotly.Blazor.Traces.ScatterGeoLib
@implements IDisposable
@inject ITravelingSalesManService travelingSalesManService
@inject ILogger<TravelingSalesMan> logger

<ProgressBar Show="_init && _loading" />

<h3>Traveling Sales Man</h3>

<ContentWithLoader Loading="_init">
    <Condition Evaluation="_locations.Count > 0">
        <NotMatch>
            <h4>No data available at the moment..</h4>
        </NotMatch>
        <Match>
            <h4>Algorithms</h4>

            <TravelingSalesManAlgorithmsDropDown Value="_algorithm" ValueChanged="SetAlgo" Disabled="_loading" />

            <Condition Evaluation="_algorithm != TravelingSalesManAlgorithms.None">
                <NotMatch>
                    <small class="text-muted">Select an algorithm to get started!</small>
                </NotMatch>
                <Match>
                    <div class="traveling-salesman-locations-container mt-3">
                        <h4>Number of Locations</h4>

                        <RangeSelector Min="_minSliderValue"
                                       Max="_maxSliderValue"
                                       Step="1"
                                       Value="_sliderValue"
                                       ValueChanged="UpdateState"
                                       Disabled="_loading" />
                    </div>

                    <TravelingSalesManLocations Locations="_locationsBySelection" CssClass="mt-3" />

                    <TravelingSalesManMatrix Matrix="_matrix" CssClass="mt-3" />

                    <TravelingSalesManMap MapChartData="_mapChartData"
                                          CssClass="mt-3"
                                          LandColor="rgb(243,243,243)"
                                          CountryColor="rgb(204,204,204)" />

                    <TravelingSalesManPie PieChartData="_pieChartData" CssClass="mt-3" />
                </Match>
            </Condition>
        </Match>
    </Condition>
</ContentWithLoader>

@code {
    private CancellationTokenSource _cts = new();
    private bool _init = false;
    private bool _loading = false;

    private List<LocationGeo> _locations = new();
    private List<LocationGeo> _locationsBySelection = new();
    private List<LocationRow> _matrix = new();

    private TravelingSalesManAlgorithms _algorithm;

    private int _minSliderValue = 1;
    private int _maxSliderValue = 10;
    private int _sliderValue = 1;

    private List<ITrace> _mapChartData = new();
    private List<ITrace> _pieChartData = new();

    protected override async Task OnInitializedAsync()
    {
        _init = false;

        _locations = await travelingSalesManService.Fetch(_maxSliderValue, _cts.Token);

        await Task.Delay(250, _cts.Token).ContinueWith(_ => _init = true);
    }

    private void Reset()
    {
        _mapChartData.Clear();
        _pieChartData.Clear();

        _sliderValue = _minSliderValue;

        _locationsBySelection.Clear();
        _matrix.Clear();
    }

    private async Task SetAlgo(TravelingSalesManAlgorithms algo)
    {
        _algorithm = algo;

        if (_algorithm == TravelingSalesManAlgorithms.None)
        {
            Reset();

            return;
        }

        _loading = true;

        if (_locationsBySelection.Count == 0)
            await UpdateState(_minSliderValue);

        await Task.Delay(250);

        _loading = false;
        StateHasChanged();
    }

    private Task UpdateState(int sliderValue) => UpdateState(sliderValue, false);

    private async Task UpdateState(int sliderValue, bool deferNotifyingStateChanged)
    {
        try
        {
            _sliderValue = sliderValue;
            _locationsBySelection = _locations.Take(_sliderValue).ToList();
            _matrix = await travelingSalesManService.CalculateMatrix(_locationsBySelection, _cts.Token);

            var mapMarkerData =
                await travelingSalesManService.CalculateMapMarkers(_locationsBySelection, _cts.Token) is { Count: > 0 } mc
                    ? mc
                    : new List<ITrace> { new ScatterGeo { LocationMode = LocationModeEnum.ISO3 } };
            var samplePieData =
                await Task.Run(
                    () =>
                    {
                        var pieChartDataDict =
                            _matrix.Aggregate<LocationRow, Dictionary<string, LocationToLocation>>(
                                new Dictionary<string, LocationToLocation>(),
                                (result, row) =>
                                {
                                    if (row.Min is { } min)
                                        result[min.Key] = min;

                                    return result;
                                }
                            );

                        return new Pie
                        {
                            Labels = pieChartDataDict.Values.Select(x => $"{x.DirectionalKey} | {x.ReverseDirectionalKey}").ToList<object>(),
                            Values = pieChartDataDict.Values.Select(x => (object)(long)(x.DistanceInMeters / 1000)).ToList()
                        };
                    },
                    _cts.Token
                );

            _mapChartData.Clear();
            _mapChartData.AddRange(mapMarkerData);
            _pieChartData.Clear();
            _pieChartData.Add(samplePieData);

            if (!deferNotifyingStateChanged) StateHasChanged();
        }
        catch (Exception ex)
        {

            logger.LogError(ex, ex.Message);
        }
    }

    public void Dispose()
    {
        _cts.Cancel();
    }
}
