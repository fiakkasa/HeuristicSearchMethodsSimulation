@page "/TravelingSalesMan"
@using Plotly.Blazor
@using Plotly.Blazor.Traces
@using Plotly.Blazor.ConfigLib
@using GeoCoordinatePortable
@implements IDisposable
@inject AutoMapper.IMapper mapper

<h3>Traveling Sales Man</h3>

<Condition Evaluation="_loading">
    <Match>
        <h4 class="d-flex align-items-center">
            <strong class="text-muted">Loading...</strong>
            <span class="flex-fill"></span>
            <i class="spinner-border border-2 text-secondary" role="status" aria-hidden="true"></i>
        </h4>
    </Match>
    <NotMatch>
        <RangeSelector Min="_minSliderValue" Max="_maxSliderValue" Step="1" Value="_sliderValue" ValueChanged="UpdateElements" />

        <br />

        <h4>Locations</h4>

        <div class="table-responsive">
            <table class="table table-striped table-borderless m-0">
                <thead>
                    <tr>
                        <th>@nameof(Location.Label)</th>
                        <th>@nameof(Location.ShortCode)</th>
                        <th>@nameof(Location.Latitude)</th>
                        <th>@nameof(Location.Longitude)</th>
                    </tr>
                </thead>
                <tbody>
                    <Iterations T="Location" Items="_locationsBySelection">
                        <tr>
                            <td>@context.Label</td>
                            <td>@context.ShortCode</td>
                            <td>@context.Latitude</td>
                            <td>@context.Longitude</td>
                        </tr>
                    </Iterations>
                </tbody>
            </table>
        </div>

        <Condition Evaluation="_matrix.Count > 1">
            <Match>
                <br />

                <h4>Matrix</h4>

                <div class="table-responsive">
                    <table class="table table-borderless m-0">
                        <tbody>
                            <tr>
                                <th></th>
                                <Iterations T="string" Items="_matrix[0].Xlabels">
                                    <th>@context</th>
                                </Iterations>
                            </tr>
                            <Iterations T="LocationRow" Items="_matrix">
                                <tr>
                                    <th>@context.Ylabel</th>
                                    <Iterations T="LocationToLocation" Items="context.Collection" Context="childContext">
                                        <td class="@CellCssClass(context, childContext)">
                                            @childContext.DistanceInMeters.ToString("0, Km")
                                        </td>
                                    </Iterations>
                                </tr>
                            </Iterations>
                        </tbody>
                    </table>
                </div>

            </Match>
        </Condition>
    </NotMatch>
</Condition>

<div class="@(_loading || _matrix.Count <= 2 ? "d-none" : string.Empty)">
    <br />

    <div class="flex-shrink-0 d-flex justify-content-center overflow-hidden">
        <PlotlyChart Config="_chartConfig" Layout="_chartLayout" Data="_chartData" @ref="_chartRef" style="min-height: none; height: auto;" />
    </div>
</div>

@code {
    private bool _loading = true;

    private List<LocationGeo> _locations = new();

    private int _minSliderValue = 0;
    private int _maxSliderValue = 0;
    private int _sliderValue = 0;

    private PlotlyChart? _chartRef;
    private readonly Config _chartConfig = new()
    {
        Responsive = false,
        DisplayLogo = false,
        DisplayModeBar = DisplayModeBarEnum.False,
        AutoSizable = false,
        ShowTips = false,
    };
    private readonly Layout _chartLayout = new()
    {
        Width = 400,
        Height = 200,
        AutoSize = false,
        ShowLegend = false,
        Margin = new()
        {
            AutoExpand = false,
            B = 0,
            L = 0,
            R = 0,
            T = 0,
            Pad = 0
        }
    };
    private readonly List<ITrace> _chartData = new List<ITrace> { new Pie() };
    private List<LocationGeo> _locationsBySelection = new();
    private List<LocationRow> _matrix = new();

    protected override async Task OnInitializedAsync()
    {
        _loading = true;

        //await Task.Delay(2000);

        // todo: get from service
        _locations = new List<Location> {
            new()
            {
                Id = Guid.NewGuid(),
                Label = "New York",
                ShortCode = "NYC",
                Latitude = 40.730610,
                Longitude = -73.935242,
                Ordinal = 1
            },
            new()
            {
                Id = Guid.NewGuid(),
                Label = "Atlanta",
                ShortCode = "ATL",
                Latitude = 33.753746,
                Longitude = -84.386330,
                Ordinal = 2
            },
             new()
             {
                 Id = Guid.NewGuid(),
                 Label = "Chicago",
                 ShortCode = "CHI",
                 Latitude = 41.881832,
                 Longitude = -87.623177,
                 Ordinal = 3
             },
             new()
             {
                 Id = Guid.NewGuid(),
                 Label = "Dallas",
                 ShortCode = "DAL",
                 Latitude = 32.779167,
                 Longitude = -96.808891,
                 Ordinal = 4
             },
             new()
             {
                 Id = Guid.NewGuid(),
                 Label = "Las Vegas",
                 ShortCode = "LVG",
                 Latitude = 36.114647,
                 Longitude = -115.172813,
                 Ordinal = 5
             },
             new()
             {
                 Id = Guid.NewGuid(),
                 Label = "Miami",
                 ShortCode = "MIA",
                 Latitude = 36.881817,
                 Longitude = -94.871750,
                 Ordinal = 6
             },
             new()
             {
                 Id = Guid.NewGuid(),
                 Label = "Richmond",
                 ShortCode = "RMD",
                 Latitude = 37.935757,
                 Longitude = -122.347748,
                 Ordinal = 7
             },
             new()
             {
                 Id = Guid.NewGuid(),
                 Label = "Salt Lake City",
                 ShortCode = "SLC",
                 Latitude = 40.758701,
                 Longitude = -111.876183,
                 Ordinal = 8
             },
             new()
             {
                 Id = Guid.NewGuid(),
                 Label = "Tulsa",
                 ShortCode = "TUL",
                 Latitude = 36.153980,
                 Longitude = -95.992775,
                 Ordinal = 9
             }
        }
        .Select(x => mapper.Map<LocationGeo>(x) with { Geo = new GeoCoordinate(x.Latitude, x.Longitude) })
        .ToList();

        _minSliderValue = _locations.Count > 0 ? 1 : 0;
        _maxSliderValue = _locations.Count;
        await UpdateElements(_minSliderValue);

        _loading = false;
        StateHasChanged();
    }

    private string CellCssClass(LocationRow row, LocationToLocation cell) => (
        (row, cell) switch
        {
            { row: { Min: { } }, cell: _ } when row.Min.Key == cell.Key => "min-distance text-success",
            { row: { Max: { } }, cell: _ } when row.Max.Key == cell.Key => "max-distance text-danger",
            { row: _, cell: { DistanceInMeters: 0 } } => "text-muted",
            _ => string.Empty
        } + $" ordinal-from-origin-{cell.OrdinalFromOrigin}"
    ).Trim();



    private async Task UpdateElements(int sliderValue)
    {
        _sliderValue = sliderValue;
        _locationsBySelection = _locations.Take(_sliderValue).ToList();
        _matrix =
            _locationsBySelection.Select(
                location =>
                {
                    var rowCollection =
                        _locationsBySelection.Select(
                            (otherLocation, index) =>
                                new LocationToLocation(
                                    A: location,
                                    B: otherLocation,
                                    DirectionalKey: $"{location.ShortCode}-{otherLocation.ShortCode}",
                                    ReverseDirectionalKey: $"{otherLocation.ShortCode}-{location.ShortCode}",
                                    Key: location.ShortCode.CompareTo(otherLocation.ShortCode) <= 0
                                        ? $"{location.ShortCode}-{otherLocation.ShortCode}"
                                        : $"{otherLocation.ShortCode}-{location.ShortCode}",
                                    DistanceInMeters: (location, otherLocation) switch
                                    {
                                        { location: { Geo: { } lcGeo } lc, otherLocation: { Geo: { } olcGeo } } => lcGeo.GetDistanceTo(olcGeo),
                                        _ => 0
                                    },
                                    Index: index,
                                    OrdinalFromOrigin: 0
                                )
                            )
                            .OrderBy(x => x.DistanceInMeters)
                            .Select((x, ordinalFromOrigin) => x with { OrdinalFromOrigin = ordinalFromOrigin })
                            .OrderBy(x => x.Index)
                            .ToList();

                    var selfKey = $"{location.ShortCode}-{location.ShortCode}";

                    return new LocationRow(
                        Collection: rowCollection,
                        Ylabel: location.Label,
                        Xlabels: _locationsBySelection.Select(x => x.Label).ToList(),
                        Min: rowCollection.Where(x => x.Key != selfKey).Min(),
                        Max: rowCollection.Where(x => x.Key != selfKey).Max()
                    );
                }
             ).ToList();

        var chartData = _matrix.Aggregate<LocationRow, Dictionary<string, LocationToLocation>>(
                new Dictionary<string, LocationToLocation>(),
                (result, row) =>
                {
                    if (row.Min is { } min)
                        result[min.Key] = min;

                    return result;
                }
            );
        _chartData[0] =
            new Pie
            {
                Labels = chartData.Values.Select(x => $"{x.DirectionalKey} | {x.ReverseDirectionalKey}").ToList<object>(),
                Values = chartData.Values.Select(x => (object)(long)(x.DistanceInMeters / 1000)).ToList()
            };

        if (_chartRef is { } c)
            await Task.Run(() => c?.React());
    }

    public void Dispose()
    {
        _chartRef?.Dispose();
    }
}
