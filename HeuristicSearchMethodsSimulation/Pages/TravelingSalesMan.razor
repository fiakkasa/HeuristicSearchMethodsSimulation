@page "/TravelingSalesMan"
@using Plotly.Blazor
@using Plotly.Blazor.Traces
@using Plotly.Blazor.ConfigLib
@using Plotly.Blazor.LayoutLib
@using Plotly.Blazor.LayoutLib.GeoLib
@using Plotly.Blazor.LayoutLib.GeoLib.ProjectionLib
@using Plotly.Blazor.Traces.ScatterGeoLib
@using GeoCoordinatePortable
@implements IDisposable
@inject AutoMapper.IMapper mapper

<h3>Traveling Sales Man</h3>

<Condition Evaluation="_loading">
    <Match>
        <h4 class="d-flex align-items-center">
            <strong class="text-muted">Loading...</strong>
            <span class="flex-fill"></span>
            <i class="spinner-border border-2 text-secondary" role="status" aria-hidden="true"></i>
        </h4>
    </Match>
    <NotMatch>
        <RangeSelector Min="_minSliderValue" Max="_maxSliderValue" Step="1" Value="_sliderValue" ValueChanged="UpdateElements" />

        <br />

        <h4>Locations</h4>

        <div class="table-responsive">
            <table class="table table-striped table-borderless m-0">
                <thead>
                    <tr>
                        <th>@nameof(Location.Label)</th>
                        <th>@nameof(Location.ShortCode)</th>
                        <th>@nameof(Location.Latitude)</th>
                        <th>@nameof(Location.Longitude)</th>
                    </tr>
                </thead>
                <tbody>
                    <Iterations T="Location" Items="_locationsBySelection">
                        <tr>
                            <td>@context.Label</td>
                            <td>@context.ShortCode</td>
                            <td>@context.Latitude</td>
                            <td>@context.Longitude</td>
                        </tr>
                    </Iterations>
                </tbody>
            </table>
        </div>

        <Condition Evaluation="_matrix.Count > 1">
            <Match>
                <br />

                <h4>Matrix</h4>

                <div class="table-responsive">
                    <table class="table table-borderless m-0">
                        <tbody>
                            <tr>
                                <th></th>
                                <Iterations T="string" Items="_matrix[0].Xlabels">
                                    <th>@context</th>
                                </Iterations>
                            </tr>
                            <Iterations T="LocationRow" Items="_matrix">
                                <tr>
                                    <th>@context.Ylabel</th>
                                    <Iterations T="LocationToLocation" Items="context.Collection" Context="childContext">
                                        <td class="@CellCssClass(context, childContext)">
                                            @childContext.DistanceInMeters.ToString("0, Km")
                                        </td>
                                    </Iterations>
                                </tr>
                            </Iterations>
                        </tbody>
                    </table>
                </div>

            </Match>
        </Condition>
    </NotMatch>
</Condition>

<div class="@(_loading ? "d-none" : string.Empty)">
    <br />

    <div class="flex-shrink-0 d-flex justify-content-center overflow-hidden pb-3">
        <PlotlyChart Config="_mapChartConfig" Layout="_mapChartLayout" Data="_mapChartData" @ref="_mapChartRef" style="min-height: 0; height: auto; transform: scale(1.25);" />
    </div>
</div>

<div class="@(_loading || _matrix.Count <= 2 ? "d-none" : string.Empty)">
    <br />

    <div class="flex-shrink-0 d-flex justify-content-center overflow-hidden">
        <PlotlyChart Config="_pieChartConfig" Layout="_pieChartLayout" Data="_pieChartData" @ref="_pieChartRef" style="min-height: 0; height: auto;" />
    </div>
</div>

@code {
    private bool _loading = true;

    private List<LocationGeo> _locations = new();
    private List<LocationGeo> _locationsBySelection = new();
    private List<LocationRow> _matrix = new();

    private int _minSliderValue = 1;
    private int _maxSliderValue = 10;
    private int _sliderValue = 1;

    private PlotlyChart? _mapChartRef;
    private readonly Config _mapChartConfig = new()
    {
        Responsive = false,
        DisplayLogo = false,
        DisplayModeBar = DisplayModeBarEnum.False,
        AutoSizable = false,
        ShowTips = false,
    };
    private readonly Layout _mapChartLayout = new()
    {
        Width = 640,
        Height = 450,
        AutoSize = false,
        ShowLegend = false,
        Margin = new()
        {
            AutoExpand = false,
            B = 0,
            L = 0,
            R = 0,
            T = 0,
            Pad = 0
        },
        DragMode = DragModeEnum.False,
        Geo = new List<Geo> {
            new Geo
            {
                Scope = ScopeEnum.NorthAmerica,
                Projection = new Projection
                {
                    Type = TypeEnum.AzimuthalEqualArea
                },
                ShowLand = true,
                LandColor = "rgb(243,243,243)",
                CountryColor = "rgb(204,204,204)"
            }
        },
    };
    private List<ITrace> _mapChartData = new List<ITrace> { new ScatterGeo { LocationMode = LocationModeEnum.ISO3 } };

    private PlotlyChart? _pieChartRef;
    private readonly Config _pieChartConfig = new()
    {
        Responsive = false,
        DisplayLogo = false,
        DisplayModeBar = DisplayModeBarEnum.False,
        AutoSizable = false,
        ShowTips = false,
    };
    private readonly Layout _pieChartLayout = new()
    {
        Width = 200,
        Height = 200,
        AutoSize = false,
        ShowLegend = false,
        Margin = new()
        {
            AutoExpand = false,
            B = 0,
            L = 0,
            R = 0,
            T = 0,
            Pad = 0
        }
    };
    private readonly List<ITrace> _pieChartData = new List<ITrace> { new Pie() };

    protected override async Task OnInitializedAsync()
    {
        _loading = true;

        //await Task.Delay(2000);

        // todo: get from service
        _locations = new List<Location> {
            new()
            {
                Id = Guid.NewGuid(),
                Label = "New York",
                ShortCode = "NYC",
                Latitude = 40.71427,
                Longitude = -74.00597,
                Ordinal = 1
            },
            new()
            {
                Id = Guid.NewGuid(),
                Label = "Atlanta",
                ShortCode = "ATL",
                Latitude = 33.749,
                Longitude = -84.38798,
                Ordinal = 2
            },
             new()
             {
                 Id = Guid.NewGuid(),
                 Label = "Chicago",
                 ShortCode = "CHI",
                 Latitude = 41.85003,
                 Longitude = -87.65005,
                 Ordinal = 3
             },
             new()
             {
                 Id = Guid.NewGuid(),
                 Label = "Dallas",
                 ShortCode = "DAL",
                 Latitude = 32.78306,
                 Longitude = -96.80667,
                 Ordinal = 4
             },
             new()
             {
                 Id = Guid.NewGuid(),
                 Label = "Las Vegas",
                 ShortCode = "LVG",
                 Latitude = 36.17497,
                 Longitude = -115.13722,
                 Ordinal = 5
             },
             new()
             {
                 Id = Guid.NewGuid(),
                 Label = "Miami",
                 ShortCode = "MIA",
                 Latitude = 25.77427,
                 Longitude = -80.19366,
                 Ordinal = 6
             },
             new()
             {
                 Id = Guid.NewGuid(),
                 Label = "Richmond",
                 ShortCode = "RMD",
                 Latitude = 37.55376,
                 Longitude = -77.46026,
                 Ordinal = 7
             },
             new()
             {
                 Id = Guid.NewGuid(),
                 Label = "Salt Lake City",
                 ShortCode = "SLC",
                 Latitude = 40.76078,
                 Longitude = -111.89105,
                 Ordinal = 8
             },
             new()
             {
                 Id = Guid.NewGuid(),
                 Label = "Tulsa",
                 ShortCode = "TUL",
                 Latitude = 36.15398,
                 Longitude = -95.99277,
                 Ordinal = 9
             }
        }
        .Take(_maxSliderValue)
        .Select(x => mapper.Map<LocationGeo>(x) with { Geo = new GeoCoordinate(x.Latitude, x.Longitude) })
        .ToList();

        await UpdateElements(_minSliderValue);

        _loading = false;
        StateHasChanged();
    }

    private string CellCssClass(LocationRow row, LocationToLocation cell) => (
        (row, cell) switch
        {
            { row: { Min: { } }, cell: _ } when row.Min.Key == cell.Key => "min-distance text-success",
            { row: { Max: { } }, cell: _ } when row.Max.Key == cell.Key => "max-distance text-danger",
            { row: _, cell: { DistanceInMeters: 0 } } => "text-muted",
            _ => string.Empty
        } + $" ordinal-from-origin-{cell.OrdinalFromOrigin}"
    ).Trim();

    private async Task UpdateElements(int sliderValue)
    {
        _sliderValue = sliderValue;
        _locationsBySelection = _locations.Take(_sliderValue).ToList();
        _matrix =
            _locationsBySelection.Select(
                location =>
                {
                    var rowCollection =
                        _locationsBySelection.Select(
                            (otherLocation, index) =>
                                new LocationToLocation(
                                    A: location,
                                    B: otherLocation,
                                    DirectionalKey: $"{location.ShortCode}-{otherLocation.ShortCode}",
                                    ReverseDirectionalKey: $"{otherLocation.ShortCode}-{location.ShortCode}",
                                    Key: location.ShortCode.CompareTo(otherLocation.ShortCode) <= 0
                                        ? $"{location.ShortCode}-{otherLocation.ShortCode}"
                                        : $"{otherLocation.ShortCode}-{location.ShortCode}",
                                    DistanceInMeters: (location, otherLocation) switch
                                    {
                                        { location: { Geo: { } lcGeo } lc, otherLocation: { Geo: { } olcGeo } } => lcGeo.GetDistanceTo(olcGeo),
                                        _ => 0
                                    },
                                    Index: index,
                                    OrdinalFromOrigin: 0
                                )
                            )
                            .OrderBy(x => x.DistanceInMeters)
                            .Select((x, ordinalFromOrigin) => x with { OrdinalFromOrigin = ordinalFromOrigin })
                            .OrderBy(x => x.Index)
                            .ToList();

                    var selfKey = $"{location.ShortCode}-{location.ShortCode}";

                    return new LocationRow(
                        Collection: rowCollection,
                        Ylabel: location.Label,
                        Xlabels: _locationsBySelection.Select(x => x.Label).ToList(),
                        Min: rowCollection.Where(x => x.Key != selfKey).Min(),
                        Max: rowCollection.Where(x => x.Key != selfKey).Max()
                    );
                }
             ).ToList();

        _mapChartData.Clear();
        _mapChartData.AddRange(
            _locationsBySelection.Count == 0
            ? new List<ITrace> { new ScatterGeo { LocationMode = LocationModeEnum.ISO3 } }
            : _locationsBySelection.Select(x =>
                new ScatterGeo
                {
                    LocationMode = LocationModeEnum.ISO3,
                    Lon = new List<object> { x.Longitude },
                    Lat = new List<object> { x.Latitude },
                    Mode = ModeFlag.Markers,
                    Text = x.Label,
                    Name = x.ShortCode,
                    HoverInfo = HoverInfoFlag.Lat | HoverInfoFlag.Lon | HoverInfoFlag.Text | HoverInfoFlag.Name
                }
            )
            .ToList<ITrace>()
        );

        if (_mapChartRef is { } m)
            m?.React();

        var pieChartData = _matrix.Aggregate<LocationRow, Dictionary<string, LocationToLocation>>(
            new Dictionary<string, LocationToLocation>(),
            (result, row) =>
            {
                if (row.Min is { } min)
                    result[min.Key] = min;

                return result;
            }
        );
        _pieChartData.Clear();
        _pieChartData.Add(
            new Pie
            {
                Labels = pieChartData.Values.Select(x => $"{x.DirectionalKey} | {x.ReverseDirectionalKey}").ToList<object>(),
                Values = pieChartData.Values.Select(x => (object)(long)(x.DistanceInMeters / 1000)).ToList()
            }
        );

        if (_pieChartRef is { } c)
            await Task.Run(() => c?.React());

    }

    public void Dispose()
    {
        _pieChartRef?.Dispose();
    }
}
